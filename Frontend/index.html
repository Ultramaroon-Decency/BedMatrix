<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BedMatrix | Hospital Bed & Blood Bank Tracker</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    /* ------------------------------------------------------------
       üé® BEDMATRIX MODERN PREMIUM UI - DESIGN SYSTEM
       ------------------------------------------------------------ */

    /* 1. RESET & VARIABLES */
    :root {
      /* Palette: Modern Deep Indigo & Medical Teal */
      --primary: #4F46E5;
      /* Indigo 600 */
      --primary-dark: #4338CA;
      /* Indigo 700 */
      --secondary: #06B6D4;
      /* Cyan 500 */
      --secondary-dark: #0891B2;
      /* Cyan 600 */

      /* Accents */
      --accent-success: #10B981;
      --accent-warning: #F59E0B;
      --accent-danger: #EF4444;

      /* Neutrals */
      --bg-body: #F8FAFC;
      /* Slate 50 */
      --bg-surface: #FFFFFF;
      --text-main: #0F172A;
      /* Slate 900 */
      --text-muted: #64748B;
      /* Slate 500 */
      --border-light: #E2E8F0;
      /* Slate 200 */

      /* Effects */
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.05), 0 4px 6px -2px rgba(0, 0, 0, 0.025);
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --font-main: 'Inter', system-ui, -apple-system, sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
      font-size: 16px;
    }

    body {
      background: var(--bg-body);
      color: var(--text-main);
      font-family: var(--font-main);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }

    /* 2. TYPOGRAPHY */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: var(--text-main);
      line-height: 1.2;
      font-weight: 700;
    }

    a {
      text-decoration: none;
      transition: 0.2s ease;
    }

    /* Utility Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-fade {
      animation: fadeIn 0.6s ease-out forwards;
    }


    /* 3. NAVBAR (Glassmorphism) */
    nav {
      background: rgba(255, 255, 255, 0.85);
      /* Translucent */
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 1rem 5%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: var(--shadow-sm);
      transform: translateY(-100%);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    nav.nav-visible {
      transform: translateY(0);
      opacity: 1;
    }

    nav h1 {
      font-size: 1.5rem;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      letter-spacing: -0.02em;
    }

    nav ul {
      list-style: none;
      display: flex;
      gap: 2rem;
      align-items: center;
    }

    nav ul li a {
      color: var(--text-muted);
      font-weight: 500;
      font-size: 0.95rem;
      position: relative;
    }

    nav ul li a:hover,
    nav ul li a.active {
      color: var(--primary);
    }

    /* Navbar Link Animated Underline */
    nav ul li a::after {
      content: '';
      position: absolute;
      width: 0%;
      height: 2px;
      bottom: -4px;
      left: 0;
      background: var(--primary);
      transition: width 0.3s ease;
      border-radius: 2px;
    }

    nav ul li a:hover::after {
      width: 100%;
    }


    /* 4. SECTIONS */
    section {
      padding: 4rem 5%;
    }

    h2.section-title {
      text-align: center;
      font-size: 2.25rem;
      margin-bottom: 3rem;
      position: relative;
    }

    /* Decorative underline for titles */
    h2.section-title::after {
      content: '';
      display: block;
      width: 60px;
      height: 4px;
      background: linear-gradient(to right, var(--primary), var(--secondary));
      margin: 0.8rem auto 0;
      border-radius: 2px;
    }

    /* 5. HERO SECTION */
    .hero {
      text-align: center;
      padding: 6rem 1rem;
      background: radial-gradient(circle at top right, #E0E7FF 0%, transparent 40%),
        radial-gradient(circle at bottom left, #CCFBF1 0%, transparent 40%),
        var(--bg-body);
      overflow: hidden;
      position: relative;
      min-height: 100vh;
      min-height: 100dvh;
      /* Full viewport height ‚Äì dvh accounts for mobile browser chrome */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* Three.js 3D Canvas */
    #threejs-hero-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .hero h2,
    .hero p,
    .hero button,
    .scroll-indicator {
      position: relative;
      z-index: 1;
    }

    /* Scroll Indicator Arrow */
    .scroll-indicator {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      animation: bounce 2s infinite;
      color: var(--primary);
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    .scroll-indicator:hover {
      opacity: 1;
    }

    .scroll-indicator span {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-muted);
    }

    .scroll-indicator svg {
      width: 28px;
      height: 28px;
    }

    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateX(-50%) translateY(0);
      }

      40% {
        transform: translateX(-50%) translateY(-10px);
      }

      60% {
        transform: translateX(-50%) translateY(-5px);
      }
    }

    /* Section title animation */
    .section-title.scroll-revealed {
      animation: fadeSlideUp 0.6s ease-out forwards;
    }

    @keyframes fadeSlideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .hero h2 {
      font-size: 3.5rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(135deg, #1E293B 0%, #334155 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.03em;
    }

    .hero p {
      max-width: 700px;
      margin: 0 auto 2rem;
      font-size: 1.25rem;
      color: var(--text-muted);
    }

    .hero button {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      padding: 1rem 2.5rem;
      border: none;
      border-radius: 50px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 10px 25px -5px rgba(79, 70, 229, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .hero button:hover {
      transform: translateY(-2px);
      box-shadow: 0 15px 30px -5px rgba(79, 70, 229, 0.5);
    }

    /* 6. FEATURES (Cards) */
    .features-section {
      position: relative;
      overflow: hidden;
    }

    /* Three.js 3D Canvas for Features */
    #threejs-features-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .features-section .section-title {
      position: relative;
      z-index: 1;
    }

    /* Carousel wrapper */
    .features-marquee-wrapper {
      overflow: hidden;
      position: relative;
      z-index: 1;
      padding: 1rem 0;
    }

    .features-grid {
      display: flex;
      gap: 2rem;
      width: max-content;
      animation: marquee 25s linear infinite;
      transition: none;
    }

    /* Pause and switch to step mode on hover */
    .features-grid.step-mode {
      animation: none;
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes marquee {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-50%);
      }
    }

    /* Feature Navigation Controls - Side positioned */
    .feature-nav-btn {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: rgba(255, 255, 255, 0.9);
      color: var(--primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 10;
    }

    .feature-nav-btn#feature-prev {
      left: 1rem;
    }

    .feature-nav-btn#feature-next {
      right: 1rem;
    }

    .feature-nav-btn:hover {
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
    }

    /* Pause animation when hovering on buttons */
    .feature-nav-btn:hover~.features-marquee-wrapper .features-grid,
    .features-section:has(.feature-nav-btn:hover) .features-grid {
      animation-play-state: paused;
    }

    .feature-nav-btn svg {
      width: 20px;
      height: 20px;
    }

    .feature-card {
      background: var(--bg-surface);
      padding: 2rem;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
      border: 2px solid var(--border-light);
      text-align: left;
      position: relative;
      min-width: 280px;
      max-width: 280px;
      min-height: 200px;
      flex-shrink: 0;
    }

    /* Invisible extended hover zone to prevent jiggle at edges */
    .feature-card::before {
      content: '';
      position: absolute;
      top: -15px;
      left: -15px;
      right: -15px;
      bottom: -15px;
      z-index: -1;
    }

    .feature-card:hover {
      transform: translateY(-10px);
      box-shadow:
        0 20px 40px -10px rgba(99, 102, 241, 0.3),
        0 10px 20px -5px rgba(6, 182, 212, 0.2);
      border-color: var(--primary);
    }

    /* Icon animation on hover */
    .feature-card:hover .feature-icon {
      transform: scale(1.15) rotate(5deg);
      filter: drop-shadow(0 4px 8px rgba(99, 102, 241, 0.3));
    }

    /* Title glow on hover */
    .feature-card:hover .feature-title {
      color: var(--primary);
    }

    .feature-icon {
      width: 64px;
      height: 64px;
      margin-bottom: 1.5rem;
      padding: 12px;
      background: #EEF2FF;
      border-radius: 16px;
      object-fit: contain;
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), filter 0.4s ease;
    }

    .feature-title {
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
      color: var(--text-main);
      transition: color 0.3s ease;
    }

    .feature-desc {
      font-size: 1rem;
      color: var(--text-muted);
    }

    /* 7. DASHBOARD & SEARCH */
    .dashboard table {
      width: 100%;
      max-width: 1100px;
      margin: 0 auto;
      border-collapse: separate;
      /* For rounded corners */
      border-spacing: 0;
      box-shadow: var(--shadow-md);
      border-radius: var(--radius-md);
      overflow: hidden;
      background: var(--bg-surface);
      /* Scroll reveal - initial hidden state */
      opacity: 0;
      transform: translateY(50px) scale(0.95);
      transition: opacity 0.6s ease, transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    /* Scroll reveal - visible state */
    .dashboard table.scroll-revealed {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    th,
    td {
      padding: 1rem 1.5rem;
      text-align: left;
      border-bottom: 1px solid var(--border-light);
    }

    th {
      background: var(--bg-body);
      color: var(--text-muted);
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 0.05em;
    }

    tr:last-child td {
      border-bottom: none;
    }

    tr:hover td {
      background: #F8FAFC;
    }

    .status {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .status::before {
      content: '';
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-right: 6px;
      background: currentColor;
    }

    .available {
      background: #ECFDF5;
      color: #059669;
    }

    .fewleft {
      background: #FFFBEB;
      color: #D97706;
    }

    .full {
      background: #FEF2F2;
      color: #DC2626;
    }

    /* Search Panel */
    .search-panel {
      max-width: 1400px;
      margin: 0 auto;
      background: var(--bg-surface);
      padding: 1.5rem;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      border: 1px solid var(--border-light);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .controls .search-input {
      flex: 1;
      min-width: 200px;
    }

    .filters {
      display: flex;
      gap: 1rem;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .filter-group {
      min-width: 150px;
    }

    /* Make inputs cleaner */
    .search-input,
    select {
      width: 100%;
      padding: 0.8rem 1rem;
      border: 1px solid var(--border-light);
      border-radius: 10px;
      font-size: 0.95rem;
      background: #F8FAFC;
      transition: 0.2s;
    }

    .search-input:focus,
    select:focus {
      outline: none;
      border-color: var(--primary);
      background: white;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }

    .filter-group label {
      display: block;
      margin-bottom: 0.4rem;
      font-size: 0.85rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .btn {
      padding: 0.8rem 1.5rem;
      background: var(--bg-body);
      color: var(--text-main);
      border: 1px solid var(--border-light);
      border-radius: 10px;
      cursor: pointer;
      font-weight: 500;
      height: 46px;
      /* Match input height roughly */
      align-self: end;
    }

    .btn:hover {
      background: #F1F5F9;
    }

    /* List & Map Layout */
    .list-and-map {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .hospital-list {
      max-height: 600px;
      overflow-y: auto;
      padding-right: 8px;
    }

    /* Scrollbar Styling */
    .hospital-list::-webkit-scrollbar {
      width: 6px;
    }

    .hospital-list::-webkit-scrollbar-thumb {
      background: #CBD5E1;
      border-radius: 3px;
    }

    .hospital-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .h-card {
      background: var(--bg-surface);
      border: 1px solid var(--border-light);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .h-card:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow-sm);
    }

    .h-card.selected {
      border-color: var(--primary);
      background: #EEF2FF;
    }

    .h-name {
      font-weight: 700;
      font-size: 1rem;
      margin-bottom: 0.25rem;
    }

    .h-wards {
      font-size: 0.85rem;
      color: var(--text-muted);
      display: flex;
      gap: 8px;
      margin-bottom: 0.5rem;
    }

    .resource-box {
      font-size: 0.75rem;
      background: #F1F5F9;
      padding: 6px 10px;
      border-radius: 6px;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    /* Map container */
    #map {
      width: 100%;
      height: 600px;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      z-index: 1;
    }

    /* 8. FAQ & LOGIN, BLOOD BANK */
    .faq-section {
      padding: 4rem 5%;
      max-width: 900px;
      margin: 0 auto;
    }

    .faq-intro {
      text-align: center;
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    .faq-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .faq-item {
      background: var(--bg-surface);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-md);
      padding: 1.25rem 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .faq-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--primary);
      border-radius: 4px 0 0 4px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .faq-item:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-md);
      border-color: #C7D2FE;
    }

    .faq-item:hover::before {
      opacity: 1;
    }

    .faq-question {
      font-weight: 600;
      font-size: 1.05rem;
      color: var(--text-main);
    }

    .faq-answer {
      margin-top: 0.75rem;
      color: var(--text-muted);
      font-size: 0.95rem;
      line-height: 1.6;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: all 0.4s ease;
    }

    .faq-item:hover .faq-answer {
      max-height: 300px;
      opacity: 1;
    }

    /* Login Form */
    .login-form {
      box-shadow: var(--shadow-lg);
      border-radius: var(--radius-xl);
      padding: 2.5rem;
    }

    /* 9. FOOTER */
    footer {
      background: #1E293B;
      /* Slate 800 */
      color: #94A3B8;
      padding: 3rem 1rem;
      margin-top: 4rem;
    }

    /* 10. RESPONSIVE */
    @media (max-width: 960px) {
      .list-and-map {
        grid-template-columns: 1fr;
      }

      .controls {
        grid-template-columns: 1fr 1fr;
      }

      .hero h2 {
        font-size: 2.5rem;
      }

      /* Tablet Dashboard Table Styles */
      .dashboard table {
        max-width: 100%;
      }

      .dashboard th,
      .dashboard td {
        padding: 0.8rem 1rem;
      }
    }

    @media (max-width: 768px) {

      /* Dashboard table wrapper for horizontal scroll */
      .dashboard {
        padding: 3rem 2%;
      }

      .dashboard table {
        display: block;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .dashboard th,
      .dashboard td {
        padding: 0.75rem 1rem;
        min-width: 80px;
      }

      .dashboard th:first-child,
      .dashboard td:first-child {
        min-width: 100px;
        position: sticky;
        left: 0;
        background: var(--bg-surface);
        z-index: 1;
      }

      .dashboard th:first-child {
        background: var(--bg-body);
      }
    }

    @media (max-width: 600px) {
      .controls {
        grid-template-columns: 1fr;
      }

      nav {
        flex-direction: column;
        gap: 1rem;
      }

      nav ul {
        gap: 1rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      /* Mobile Dashboard Table Fix */
      .dashboard {
        padding: 2rem 1rem;
      }

      .dashboard table {
        display: block;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        white-space: nowrap;
      }

      .dashboard th,
      .dashboard td {
        padding: 0.75rem 0.8rem;
        font-size: 0.85rem;
      }

      .dashboard th {
        font-size: 0.7rem;
      }

      .status {
        padding: 0.2rem 0.5rem;
        font-size: 0.75rem;
      }

      h2.section-title {
        font-size: 1.6rem;
        margin-bottom: 1.5rem;
      }
    }

    /* Leaflet Overrides for better aesthetics */
    .leaflet-popup-content-wrapper {
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      font-family: var(--font-main);
    }

    .leaflet-popup-content b {
      color: var(--primary-dark);
      font-size: 1.1rem;
    }


    /* Chatbot Styles Modernized - Blue Theme */
    .chatbot-toggle {
      position: fixed;
      bottom: 24px;
      right: 24px;
      left: auto;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: #3B82F6;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chatbot-toggle:hover {
      transform: scale(1.1) translateY(-2px);
      box-shadow: 0 10px 30px rgba(59, 130, 246, 0.5);
    }

    .chatbot-container {
      position: fixed;
      bottom: 90px;
      right: 24px;
      left: auto;
      width: 360px;
      height: 480px;
      background: #F8FAFC;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
      border: 1px solid #E2E8F0;
      overflow: hidden;
      display: none;
      flex-direction: column;
      z-index: 1002;
    }

    .chat-header {
      background: #3B82F6;
      padding: 1rem 1.2rem;
      color: white;
      font-weight: 600;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .chat-body {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .chat-msg {
      padding: 0.75rem 1rem;
      border-radius: 12px;
      max-width: 85%;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .bot-msg {
      background: #FFFFFF;
      color: #1E293B;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
      border: 1px solid #E2E8F0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .user-msg {
      background: #F1F5F9;
      color: #1E293B;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
      border: 1px solid #E2E8F0;
    }

    .chat-input {
      display: flex;
      padding: 0.75rem 1rem;
      background: #FFFFFF;
      border-top: 1px solid #E2E8F0;
      gap: 0.75rem;
      align-items: center;
    }

    .chat-input input {
      flex: 1;
      padding: 0.7rem 1rem;
      border: 1px solid #E2E8F0;
      border-radius: 8px;
      font-size: 0.9rem;
      outline: none;
      background: #FFFFFF;
    }

    .chat-input input:focus {
      border-color: #3B82F6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
    }

    .chat-input button {
      padding: 0.7rem 1.2rem;
      background: #3B82F6;
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .chat-input button:hover {
      background: #2563EB;
    }

    .room-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      margin-top: 5px;
    }

    .room-table td {
      border-bottom: 1px solid #eee;
      padding: 4px;
    }

    /* Login Popup Overlay */
    .login-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .login-popup-overlay.active {
      display: flex;
    }

    .login-popup-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border: none;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.5rem;
      color: #fff;
      z-index: 2001;
    }

    .login-popup-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .login-popup-iframe {
      width: 800px;
      max-width: 95%;
      height: 550px;
      max-height: 90vh;
      border: none;
      border-radius: 30px;
    }
  </style>
</head>

<body>

  <!-- Navbar -->
  <nav>
    <h1>üõèÔ∏è BedMatrix</h1>
    <ul>
      <li><a href="#home">Home</a></li>
      <li><a href="#features">Features</a></li>
      <li><a href="#dashboard">Dashboard</a></li>
      <li><a href="#faq">FAQ</a></li>
      <li><a href="#" onclick="openLoginPopup(); return false;">Official Login</a></li>
      <li><a href="#search-panel">Map</a></li>
      <li><a href="#blood-bank-section">Blood Banks</a></li>
    </ul>
  </nav>

  <!-- Login Popup -->
  <div class="login-popup-overlay" id="loginPopup" onclick="if(event.target===this)closeLoginPopup();">
    <button class="login-popup-close" onclick="closeLoginPopup()">‚úï</button>
    <iframe class="login-popup-iframe" src="login.html"></iframe>
  </div>

  <script>
    function openLoginPopup() {
      document.getElementById('loginPopup').classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    function closeLoginPopup() {
      document.getElementById('loginPopup').classList.remove('active');
      document.body.style.overflow = '';
    }
    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape') closeLoginPopup();
    });
  </script>

  <!-- Hero -->
  <section class="hero" id="home">
    <canvas id="threejs-hero-canvas"></canvas>
    <h2>Real-Time Hospital Bed Availability</h2>
    <p>Find available beds in General, ICU, Emergency, and Operation wards instantly. Your healthcare decisions
      simplified.</p>
    <!-- Scroll Indicator -->
    <a href="#features" class="scroll-indicator">
      <span>Scroll to explore</span>
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
        stroke-linejoin="round">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    </a>
  </section>

  <!-- Features -->
  <section class="features-section" id="features">
    <canvas id="threejs-features-canvas"></canvas>
    <h2 class="section-title">Key Features</h2>
    <div class="features-marquee-wrapper">
      <div class="features-grid">
        <!-- Original cards -->
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/2966/2966327.png" class="feature-icon" alt="real-time" />
          <h3 class="feature-title">Real-Time Availability</h3>
          <p class="feature-desc">Instant bed updates across all wards.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/483/483356.png" class="feature-icon" alt="search" />
          <h3 class="feature-title">Search & Filter</h3>
          <p class="feature-desc">Find hospitals by name, ward, or availability.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/942/942799.png" class="feature-icon" alt="admin" />
          <h3 class="feature-title">Admin Dashboard</h3>
          <p class="feature-desc">Securely update bed records.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/190/190411.png" class="feature-icon" alt="alerts" />
          <h3 class="feature-title">Smart Alerts</h3>
          <p class="feature-desc">Color-coded bed availability status.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/1048/1048953.png" class="feature-icon" alt="blood-bank" />
          <h3 class="feature-title">Blood Bank Locator</h3>
          <p class="feature-desc">Find nearest blood banks and check available blood groups instantly.</p>
        </div>
        <!-- Duplicate cards for seamless marquee loop -->
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/2966/2966327.png" class="feature-icon" alt="real-time" />
          <h3 class="feature-title">Real-Time Availability</h3>
          <p class="feature-desc">Instant bed updates across all wards.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/483/483356.png" class="feature-icon" alt="search" />
          <h3 class="feature-title">Search & Filter</h3>
          <p class="feature-desc">Find hospitals by name, ward, or availability.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/942/942799.png" class="feature-icon" alt="admin" />
          <h3 class="feature-title">Admin Dashboard</h3>
          <p class="feature-desc">Securely update bed records.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/190/190411.png" class="feature-icon" alt="alerts" />
          <h3 class="feature-title">Smart Alerts</h3>
          <p class="feature-desc">Color-coded bed availability status.</p>
        </div>
        <div class="feature-card">
          <img src="https://cdn-icons-png.flaticon.com/512/1048/1048953.png" class="feature-icon" alt="blood-bank" />
          <h3 class="feature-title">Blood Bank Locator</h3>
          <p class="feature-desc">Find nearest blood banks and check available blood groups instantly.</p>
        </div>
      </div>
    </div>
    <!-- Feature Navigation Controls -->
    <button class="feature-nav-btn" id="feature-prev" title="Scroll Left">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"
        stroke-linejoin="round">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    </button>
    <button class="feature-nav-btn" id="feature-next" title="Scroll Right">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"
        stroke-linejoin="round">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </button>
  </section>

  <!-- Dashboard -->
  <section class="dashboard" id="dashboard">
    <h2 class="section-title">Live Bed Dashboard</h2>
    <table>
      <thead>
        <tr>
          <th>Hospital</th>
          <th>General</th>
          <th>Emergency</th>
          <th>ICU</th>
          <th>Operation</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>AIIMS Delhi</td>
          <td>25/50</td>
          <td>8/15</td>
          <td>2/10</td>
          <td>1/5</td>
          <td><span class="status fewleft">Few Left</span></td>
        </tr>
        <tr>
          <td>Fortis Hospital</td>
          <td>10/40</td>
          <td>2/10</td>
          <td>1/5</td>
          <td>0/5</td>
          <td><span class="status available">Available</span></td>
        </tr>
        <tr>
          <td>Max Super Speciality</td>
          <td>8/45</td>
          <td>1/10</td>
          <td>0/6</td>
          <td>1/3</td>
          <td><span class="status fewleft">Few Left</span></td>
        </tr>
        <tr>
          <td>Safdarjung Hospital</td>
          <td>0/55</td>
          <td>0/18</td>
          <td>0/12</td>
          <td>0/6</td>
          <td><span class="status full">Full</span></td>
        </tr>
        <tr>
          <td>Medanta Hospital</td>
          <td>22/50</td>
          <td>6/14</td>
          <td>4/10</td>
          <td>2/5</td>
          <td><span class="status available">Available</span></td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- FAQ -->

  <!-- Accordion Animation Script -->
  <script>
    // FAQ accordion open/close animation
    document.querySelectorAll('.faq-question').forEach((question) => {
      question.addEventListener('click', () => {
        const answer = question.nextElementSibling;
        const isActive = answer.style.display === 'block';
        // Close all
        document.querySelectorAll('.faq-answer').forEach(a => a.style.display = 'none');
        // Open current
        answer.style.display = isActive ? 'none' : 'block';
        question.scrollIntoView({ behavior: 'smooth', block: 'center' });
      });
    });
  </script>


  <!-- Login Section -->
  <ion id="login">


    <!-- Official Login Form -->
    <form class="login-form" id="official-login" style="display:none;">
      <p style="margin-bottom:1rem;">Login with your employee credentials</p>
      <input type="text" placeholder="Employee ID" required />
      <input type="password" placeholder="Password" required />
      <a href="#"
        style="font-size:0.85rem; color:var(--primary-color); text-decoration:none; display:block; margin-bottom:0.5rem;">Forgot
        Password?</a>
      <button type="submit">Login</button>
    </form>
    </section>

    <script>
      function showLogin(type) {
        const userForm = document.getElementById('user-login');
        const officialForm = document.getElementById('official-login');
        const userBtn = document.getElementById('user-btn');
        const officialBtn = document.getElementById('official-btn');

        if (type === 'user') {
          userForm.style.display = 'block';
          officialForm.style.display = 'none';
          userBtn.style.background = 'var(--primary-color)';
          userBtn.style.color = 'white';
          officialBtn.style.background = '#E5E7EB';
          officialBtn.style.color = 'var(--text-dark)';
        } else {
          userForm.style.display = 'none';
          officialForm.style.display = 'block';
          officialBtn.style.background = 'var(--primary-color)';
          officialBtn.style.color = 'white';
          userBtn.style.background = '#E5E7EB';
          userBtn.style.color = 'var(--text-dark)';
        }
      }
    </script>
    <!-- Search & Filter Panel -->
    <section class="search-panel" id="search-panel" aria-label="Search and filter hospitals">
      <div class="controls">
        <input id="search-input" class="search-input" type="search" placeholder="Search hospitals by name..."
          aria-label="Search hospitals by name" />

        <div class="filters">
          <div class="filter-group">
            <label class="filter-label" for="ward-select">Ward</label>
            <select id="ward-select" aria-label="Filter by ward">
              <option value="any">Any</option>
              <option value="General">General</option>
              <option value="ICU">ICU</option>
              <option value="Emergency">Emergency</option>
              <option value="Operation">Operation</option>
            </select>
          </div>

          <div class="filter-group">
            <label class="filter-label" for="availability-select">Availability</label>
            <select id="availability-select" aria-label="Filter by availability">
              <option value="any">Any</option>
              <option value="available">Available (&gt;10 total)</option>
              <option value="few">Few Left (3‚Äì10)</option>
              <option value="full">Full (&le;2)</option>
            </select>
          </div>

          <div class="filter-group">
            <label style="visibility:hidden">reset</label>
            <button id="reset-filters" class="btn" aria-label="Reset filters">Reset</button>
          </div>
        </div>
      </div>

      <div class="list-and-map">
        <!-- Hospital list -->
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.6rem;">
            <div style="font-weight:600;color:var(--text-gray)">Hospitals</div>
            <div id="result-count" style="color:var(--text-gray)">Showing 0</div>
          </div>
          <div class="hospital-list" id="hospital-list" aria-live="polite"></div>
        </div>

        <!-- Map -->
        <div id="map" role="region" aria-label="Delhi hospitals and blood banks map"></div>
      </div>
    </section>

    <!-- Blood Banks Table -->
    <section id="blood-bank-section">
      <h2 style="text-align:center; margin-top:0.5rem;">ü©∏ Nearby Blood Banks</h2>
      <p style="text-align:center; color:#4B5563; max-width:760px; margin:0.5rem auto 1rem;">
        Find your nearest blood banks and check which blood groups are currently available. Click a row to center the
        map on that blood bank.
      </p>

      <table
        style="width:90%; max-width:940px; margin:0 auto 3rem; border-collapse:collapse; box-shadow:0 4px 20px rgba(0,0,0,0.05);">
        <thead>
          <tr style="background:var(--primary-color); color:white;">
            <th style="padding:0.9rem;">Blood Bank</th>
            <th style="padding:0.9rem;">Location</th>
            <th style="padding:0.9rem;">Available Blood Groups</th>
          </tr>
        </thead>
        <tbody id="blood-bank-table"></tbody>
      </table>
    </section>

    <!-- Chatbot -->
    <button class="chatbot-toggle" onclick="toggleChatbot()" title="Open chat">üí¨</button>
    <div class="chatbot-container" id="chatbot" aria-hidden="true">
      <div class="chat-header">ü©∫ BedMatrix Assistant</div>
      <div class="chat-body" id="chat-body">
        <div class="chat-msg bot-msg">Hello! üëã I‚Äôm your BedMatrix assistant. Ask about nearest hospital, emergency
          beds, or blood bank availability.</div>
      </div>
      <div class="chat-input">
        <input type="text" id="user-input" placeholder="Try: 'Nearest blood bank' or 'Is O+ available?'" />
        <button onclick="sendMessage()">Send</button>
      </div>
    </div>
    <section class="faq-section" id="faq">
      <h2 class="section-title">Frequently Asked Questions (FAQ)</h2>
      <p class="faq-intro">Hover over each question to reveal the answer instantly.</p>
      <div class="faq-container">
        <div class="faq-item">
          <div class="faq-question">üîπ What is BedMatrix?</div>
          <div class="faq-answer">BedMatrix is a real-time hospital and blood bank tracking platform that helps users
            find available beds and blood units across Delhi instantly.</div>
        </div>
        <div class="faq-item">
          <div class="faq-question">üîπ How does BedMatrix show live data?</div>
          <div class="faq-answer">Hospitals and blood banks update their data through the secure BedMatrix Admin
            Dashboard, ensuring accurate live availability.</div>
        </div>
        <div class="faq-item">
          <div class="faq-question">üîπ Can I find the nearest hospital or blood bank?</div>
          <div class="faq-answer">Yes! The BedMatrix map and chatbot help you find the nearest hospital or blood bank
            using your location.</div>
        </div>
        <div class="faq-item">
          <div class="faq-question">üîπ How can I check available blood groups?</div>
          <div class="faq-answer">Visit the Blood Bank section or hover over the red map markers to see available blood
            groups like A+, B+, O+, etc.</div>
        </div>
        <div class="faq-item">
          <div class="faq-question">üîπ Is my personal data safe?</div>
          <div class="faq-answer">Yes, BedMatrix never stores or shares personal or location data. Your privacy is fully
            protected.</div>
        </div>
        <div class="faq-item">
          <div class="faq-question">üîπ Does BedMatrix work on mobile devices?</div>
          <div class="faq-answer">Absolutely! BedMatrix is fully responsive and optimized for phones, tablets, and
            desktops.</div>
        </div>
        <div class="faq-item">
          <div class="faq-question">üîπ Who can access the Admin Dashboard?</div>
          <div class="faq-answer">Only verified hospital and government staff can log into the Admin Dashboard to manage
            bed and blood availability.</div>
        </div>
      </div>
    </section>

    <footer>
      <p>¬© <span id="year"></span> BedMatrix ‚Äî demo UI. For production, wire to live APIs and secure admin access.</p>
    </footer>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
      // small init
      document.getElementById('year').textContent = new Date().getFullYear();

      // ===== Map initialization =====
      const map = L.map('map', { zoomControl: true }).setView([28.6139, 77.2090], 12);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

      // SAMPLE hospitals (now include wards for filtering)
      const hospitals = [

        {
          id: 'H1',
          name: "AIIMS Hospital",
          lat: 28.5672,
          lon: 77.2100,
          contact: "+91-11-2658-8500",

          wards: { General: 25, ICU: 2, Emergency: 8, Operation: 1 },

          resources: { oxygen: 40, iv: 25, trolley: 8, ambulance: 4 },

          rooms: []
        },

        {
          id: 'H2',
          name: "Fortis Hospital",
          lat: 28.5562,
          lon: 77.1000,
          contact: "+91-11-4123-4567",

          wards: { General: 18, ICU: 5, Emergency: 4, Operation: 2 },

          resources: { oxygen: 32, iv: 20, trolley: 6, ambulance: 3 },

          rooms: [
            { type: "General Ward", price: 1000, available: 8 },
            { type: "Semi Private", price: 1800, available: 5 },
            { type: "Private", price: 3500, available: 3 },
            { type: "Deluxe", price: 6000, available: 2 },
            { type: "VIP", price: 9000, available: 1 }
          ]
        },

        {
          id: 'H3',
          name: "Safdarjung Hospital",
          lat: 28.5675,
          lon: 77.2097,
          contact: "+91-11-2610-3284",

          wards: { General: 35, ICU: 1, Emergency: 10, Operation: 0 },

          resources: { oxygen: 50, iv: 40, trolley: 12, ambulance: 5 },

          rooms: []
        },

        {
          id: 'H4',
          name: "Max Healthcare Saket",
          lat: 28.5286,
          lon: 77.2167,
          contact: "+91-11-2651-5050",

          wards: { General: 12, ICU: 6, Emergency: 3, Operation: 2 },

          resources: { oxygen: 22, iv: 15, trolley: 5, ambulance: 2 },

          rooms: [
            { type: "Private", price: 4000, available: 6 },
            { type: "Deluxe", price: 6500, available: 4 },
            { type: "Super Deluxe", price: 9000, available: 2 },
            { type: "VIP", price: 12000, available: 1 }
          ]
        },

        {
          id: 'H5',
          name: "Apollo Hospital Delhi",
          lat: 28.5420,
          lon: 77.2835,
          contact: "+91-11-2692-5858",

          wards: { General: 20, ICU: 4, Emergency: 6, Operation: 3 },

          resources: { oxygen: 35, iv: 22, trolley: 7, ambulance: 4 },

          rooms: [
            { type: "General Ward", price: 1200, available: 10 },
            { type: "Private", price: 4200, available: 5 },
            { type: "Deluxe", price: 7000, available: 3 },
            { type: "VIP", price: 11000, available: 2 }
          ]
        },

        {
          id: 'H6',
          name: "BLK-Max Super Specialty",
          lat: 28.6434,
          lon: 77.1890,
          contact: "+91-11-3040-3040",

          wards: { General: 14, ICU: 7, Emergency: 5, Operation: 2 },

          resources: { oxygen: 28, iv: 18, trolley: 6, ambulance: 3 },

          rooms: [
            { type: "Private", price: 3800, available: 6 },
            { type: "Deluxe", price: 6200, available: 4 },
            { type: "Super Deluxe", price: 9500, available: 2 },
            { type: "VVIP", price: 15000, available: 1 }
          ]
        }

      ];


      // create marker layer group & refs
      const hospitalLayer = L.layerGroup().addTo(map);
      const hospitalMarkers = {}; // id -> marker

      hospitals.forEach(h => {

        const popup = `
  <b>${h.name}</b><br>
  <hr></hr>
  Contact: ${h.contact}<br><br>

 
  <b>Rooms:</b><br>
  ${h.rooms.map(r => `${r.type} ‚Äì ‚Çπ${r.price} (${r.available})`).join("<br>")}
  `;




        // ‚úÖ CREATE MARKER (you removed this accidentally)
        const marker = L.marker([h.lat, h.lon]).bindPopup(popup);

        hospitalMarkers[h.id] = marker;
        hospitalLayer.addLayer(marker);
      });

      const redBloodIcon = L.icon({
        iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
        shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",

        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });



      // Blood banks (unchanged)
      const bloodBanks = [
        { id: 'B1', name: "Delhi Red Cross Blood Bank", lat: 28.5740, lon: 77.2070, location: "Central Delhi", contact: "+91-11-2334-0001", groups: ["A+", "B+", "O+", "AB+", "O-", "A-"] },
        { id: 'B2', name: "AIIMS Blood Bank", lat: 28.5678, lon: 77.2105, location: "Ansari Nagar", contact: "+91-11-2658-1234", groups: ["A+", "O+", "B-", "AB-"] },
        { id: 'B3', name: "Fortis Blood Bank", lat: 28.5565, lon: 77.1012, location: "Okhla", contact: "+91-11-4123-9999", groups: ["A+", "O+", "B+", "O-"] },
        { id: 'B4', name: "Apollo Blood Bank", lat: 28.5445, lon: 77.2693, location: "South Delhi", contact: "+91-11-2666-7777", groups: ["A+", "B+", "O+", "A-", "B-"] }
      ];
      const bloodBankMarkers = {};
      bloodBanks.forEach(b => {
        const bloodIcon = L.icon({
          iconUrl: "https://cdn-icons-png.flaticon.com/512/1048/1048953.png",
          iconSize: [28, 28],
          iconAnchor: [14, 28],
          popupAnchor: [0, -28]
        });

        const marker = L.marker([b.lat, b.lon], { icon: redBloodIcon }).addTo(map);


        const popupHtml = `<div style="font-weight:600;">${b.name}</div>
                         <div style="margin-top:6px;"><b>Location:</b> ${b.location}</div>
                         <div style="margin-top:6px;"><b>Contact:</b> ${b.contact}</div>
                         <div style="margin-top:6px;"><b>Available:</b> ${b.groups.join(", ")}</div>`;
        marker.bindPopup(popupHtml);
        bloodBankMarkers[b.id] = marker;
      });

      // Populate blood bank table (click to open)
      const tableBody = document.getElementById('blood-bank-table');
      bloodBanks.forEach(b => {
        const tr = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.innerHTML = `<td style="padding:0.8rem; border-bottom:1px solid #E5E7EB; text-align:left">${b.name}</td>
                      <td style="padding:0.8rem; border-bottom:1px solid #E5E7EB">${b.location}</td>
                      <td style="padding:0.8rem; border-bottom:1px solid #E5E7EB">${b.groups.join(", ")}</td>`;
        tr.addEventListener('click', () => {
          map.setView([b.lat, b.lon], 14, { animate: true });
          bloodBankMarkers[b.id].openPopup();
        });
        tableBody.appendChild(tr);
      });

      // Legend
      const legend = L.control({ position: "bottomright" });
      legend.onAdd = function (map) {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `
        <div style="padding:8px; border-radius:8px; background:white; box-shadow:0 4px 10px rgba(0,0,0,0.06)">
          <div style="font-weight:600; margin-bottom:6px;">Map Legend</div>
          <div style="display:flex;align-items:center;gap:8px;"><svg width="12" height="12"><circle cx="6" cy="6" r="6" fill="#0074D9"/></svg><span>Hospitals</span></div>
          <div style="display:flex;align-items:center;gap:8px;margin-top:6px"><svg width="12" height="12"><circle cx="6" cy="6" r="6" fill="#EF4444"/></svg><span>Blood Banks</span></div>
        </div>`;
        return div;
      };
      legend.addTo(map);

      // ---------------- Search & Filter Logic ----------------
      const input = document.getElementById('search-input');
      const wardSelect = document.getElementById('ward-select');
      const availabilitySelect = document.getElementById('availability-select');
      const resetBtn = document.getElementById('reset-filters');
      const listEl = document.getElementById('hospital-list');
      const countEl = document.getElementById('result-count');

      function totalBeds(h) { return Object.values(h.wards).reduce((a, b) => a + b, 0); }
      function statusClass(h) {
        const t = totalBeds(h);
        if (t > 10) return 'available';
        if (t >= 3) return 'fewleft';
        return 'full';
      }

      function renderList(arr) {
        listEl.innerHTML = '';
        if (arr.length === 0) {
          listEl.innerHTML = '<div style="color:#64748B;padding:12px">No hospitals match your filters.</div>';
          countEl.textContent = 'Showing 0';
          return;
        }
        countEl.textContent = `Showing ${arr.length}`;
        arr.forEach(h => {
          const div = document.createElement('div');
          div.className = 'h-card';
          div.dataset.id = h.id;
          div.innerHTML = `
  <div class="h-left">
    <div class="h-name">${h.name}</div>

    <div class="h-wards">
      Gen: ${h.wards.General} ‚Ä¢ ICU: ${h.wards.ICU}
    </div>

    <div class="resource-box">
      ü´Å O‚ÇÇ: ${h.resources.oxygen} |
      üíâ IV: ${h.resources.iv} |
      üöë Amb: ${h.resources.ambulance}
    </div>

    <table class="room-table">
     ${h.rooms.length ? `
<table class="room-table">
  ${h.rooms.map(r => `
    <tr>
      <td>${r.type}</td>
      <td>‚Çπ${r.price}</td>
      <td>${r.available}</td>
    </tr>
  `).join("")}
</table>
` : ""}

  </div>

  <div class="h-right">
    <div class="h-status ${statusClass(h)}">
      ${statusClass(h) === 'available' ? 'Available' : statusClass(h) === 'fewleft' ? 'Few Left' : 'Full'}
    </div>
  </div>
`;

          div.addEventListener('click', () => {
            map.setView([h.lat, h.lon], 14, { animate: true });
            hospitalMarkers[h.id].openPopup();
          });
          listEl.appendChild(div);
        });
      }

      function applyFilters() {
        const q = (input.value || '').trim().toLowerCase();
        const ward = wardSelect.value;
        const avail = availabilitySelect.value;

        let out = hospitals.filter(h => h.name.toLowerCase().includes(q));

        if (ward !== 'any') {
          out = out.filter(h => (h.wards[ward] || 0) > 0);
        }

        if (avail !== 'any') {
          out = out.filter(h => {
            const t = totalBeds(h);
            if (avail === 'available') return t > 10;
            if (avail === 'few') return t >= 3 && t <= 10;
            if (avail === 'full') return t <= 2;
            return true;
          });
        }

        // update markers: clear layer then add matched
        hospitalLayer.clearLayers();
        out.forEach(h => hospitalLayer.addLayer(hospitalMarkers[h.id]));

        renderList(out);
      }

      // debounce helper
      function debounce(fn, wait) {
        let t;
        return function (...args) { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); };
      }

      // initial render
      applyFilters();

      // events
      input.addEventListener('input', debounce(applyFilters, 180));
      wardSelect.addEventListener('change', applyFilters);
      availabilitySelect.addEventListener('change', applyFilters);
      resetBtn.addEventListener('click', () => {
        input.value = '';
        wardSelect.value = 'any';
        availabilitySelect.value = 'any';
        applyFilters();
      });

      // -------------- Chatbot (kept same) --------------
      const chatbot = document.getElementById('chatbot');
      const chatBody = document.getElementById('chat-body');
      const userInput = document.getElementById('user-input');

      function toggleChatbot() {
        const isHidden = chatbot.style.display !== 'flex';
        chatbot.style.display = isHidden ? 'flex' : 'none';
        chatbot.setAttribute('aria-hidden', !isHidden);
      }

      function addMessage(msg, sender) {
        const div = document.createElement('div');
        div.classList.add('chat-msg', sender === 'bot' ? 'bot-msg' : 'user-msg');
        div.textContent = msg;
        chatBody.appendChild(div);
        chatBody.scrollTop = chatBody.scrollHeight;
      }

      function sendMessage() {
        const raw = userInput.value.trim();
        if (!raw) return;
        addMessage(raw, 'user');
        userInput.value = '';
        setTimeout(() => botReply(raw), 350);
      }

      // Haversine & helper functions (same as previous)
      function haversine(lat1, lon1, lat2, lon2) {
        function toRad(x) { return x * Math.PI / 180; }
        const R = 6371;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function findNearestBloodBank(lat, lon) {
        let min = Infinity; let nearest = null;
        bloodBanks.forEach(b => {
          const d = haversine(lat, lon, b.lat, b.lon);
          if (d < min) { min = d; nearest = { bank: b, distance: d }; }
        });
        return nearest;
      }

      function banksWithGroup(group) {
        const normalized = group.toUpperCase().replace(/\s+/g, '');
        return bloodBanks.filter(b => b.groups.map(g => g.toUpperCase()).includes(normalized));
      }

      function replyWithNearestBloodBank() {
        if (!navigator.geolocation) {
          addMessage("Geolocation not available. Please type a city or landmark.", 'bot'); return;
        }
        addMessage("Requesting your location to find the nearest blood bank... (allow location)", 'bot');
        navigator.geolocation.getCurrentPosition(pos => {
          const lat = pos.coords.latitude; const lon = pos.coords.longitude;
          const nearest = findNearestBloodBank(lat, lon);
          if (!nearest) { addMessage("No blood banks found in our data.", 'bot'); return; }
          const b = nearest.bank; const dKm = nearest.distance.toFixed(2);
          addMessage(`Nearest blood bank: ${b.name} (${b.location}) ‚Äî approx ${dKm} km away. Available: ${b.groups.join(", ")}`, 'bot');
          map.setView([b.lat, b.lon], 14, { animate: true }); bloodBankMarkers[b.id].openPopup();
        }, err => {
          addMessage("Location access denied or failed. Please allow location access or ask by name.", 'bot');
        }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 });
      }
      const HEALTHCARE_KEYWORDS = [
        "hospital",
        "bed",
        "icu",
        "emergency",
        "blood",
        "blood bank",
        "donation",
        "ambulance",
        "health",
        "medical",
        "doctor",
        "patient",
        "ward"
      ];

      const ALLOWED_SMALL_TALK = [
        "hi",
        "hello",
        "hey",
        "thanks",
        "thank you",
        "bye",
        "goodbye",
        "ok",
        "okay"
      ];


      // bot reply (kept short)
      async function botReply(rawInput) {
        const input = (rawInput || "").toLowerCase();

        // üöß DOMAIN GUARD: healthcare-only
        const isHealthcareQuery = HEALTHCARE_KEYWORDS.some(keyword =>
          input.includes(keyword)
        );

        const isSmallTalk = ALLOWED_SMALL_TALK.some(word =>
          input === word || input.startsWith(word)
        );

        // üöß Block ONLY if it's neither healthcare nor small talk
        if (!isHealthcareQuery && !isSmallTalk) {
          // Let AI gently redirect instead of frontend
          // ‚Üí do NOT return here
        }




        /* ===============================
           RULE-BASED (FAST & PRECISE)
           =============================== */

        // Nearest blood bank
        if (
          input.includes("nearest blood") ||
          input.includes("nearest blood bank") ||
          input.includes("closest blood")
        ) {
          replyWithNearestBloodBank();
          return;
        }

        // Blood group availability (A+, O-, etc.)
        const groupMatch = rawInput.match(/(a\+|a-|b\+|b-|o\+|o-|ab\+|ab-)/i);
        if (groupMatch) {
          const group = groupMatch[0].toUpperCase();
          const banks = banksWithGroup(group);

          if (banks.length === 0) {
            addMessage(`No blood banks currently list ${group}.`, "bot");
          } else {
            addMessage(
              `${group} is available at: ${banks
                .map((b) => `${b.name} (${b.location})`)
                .join("; ")}`,
              "bot"
            );
            map.setView([banks[0].lat, banks[0].lon], 14);
            bloodBankMarkers[banks[0].id].openPopup();
          }
          return;
        }

        // Nearest hospital
        if (input.includes("nearest hospital") || input.includes("nearby hospital")) {
          if (!navigator.geolocation) {
            addMessage("Geolocation unavailable. Please search manually.", "bot");
            return;
          }

          addMessage("Locating nearest hospital... (allow location)", "bot");

          navigator.geolocation.getCurrentPosition(
            (pos) => {
              const lat = pos.coords.latitude;
              const lon = pos.coords.longitude;

              let min = Infinity;
              let nearest = null;

              hospitals.forEach((h) => {
                const d = haversine(lat, lon, h.lat, h.lon);
                if (d < min) {
                  min = d;
                  nearest = { h, d };
                }
              });

              if (nearest) {
                addMessage(
                  `Nearest hospital: ${nearest.h.name} (~${nearest.d.toFixed(
                    2
                  )} km). Contact: ${nearest.h.contact}`,
                  "bot"
                );
                map.setView([nearest.h.lat, nearest.h.lon], 14);
                hospitalMarkers[nearest.h.id].openPopup();
              } else {
                addMessage("No hospitals found.", "bot");
              }
            },
            () => addMessage("Location access denied.", "bot"),
            { enableHighAccuracy: true, timeout: 10000 }
          );
          return;
        }

        /* ===============================
           AI FALLBACK (SMART & FLEXIBLE)
           =============================== */

        addMessage("Typing...", "bot");

        try {
          const res = await fetch("https://bedmatrix-backend.onrender.com/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: rawInput }),
          });

          const data = await res.json();

          // remove "Typing..."
          chatBody.removeChild(chatBody.lastChild);

          addMessage(data.reply, "bot");
        } catch (err) {
          chatBody.removeChild(chatBody.lastChild);
          addMessage("‚ö†Ô∏è AI backend not reachable", "bot");
        }
      }



      document.getElementById('user-input').addEventListener('keydown', function (e) { if (e.key === 'Enter') sendMessage(); });


      window.sendMessage = sendMessage;
      window.toggleChatbot = toggleChatbot;

    </script>

    <!-- Three.js Hero Animation - Enhanced Interactive Version -->
    <script>
      (function () {
        // Get the canvas and hero section
        const canvas = document.getElementById('threejs-hero-canvas');
        const heroSection = document.querySelector('.hero');

        if (!canvas || !heroSection) return;

        // Enable pointer events for interactivity
        canvas.style.pointerEvents = 'auto';

        // Scene setup
        const scene = new THREE.Scene();

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, heroSection.offsetWidth / heroSection.offsetHeight, 0.1, 1000);
        camera.position.z = 30;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          alpha: true
        });
        renderer.setSize(heroSection.offsetWidth, heroSection.offsetHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Brand colors
        const colors = {
          primary: 0x4F46E5,
          secondary: 0x06B6D4,
          accent1: 0x10B981,
          accent2: 0x8B5CF6,
          highlight: 0xFFFFFF
        };

        // Arrays to hold objects
        const floatingShapes = [];
        const clickParticles = [];
        let hoveredShape = null;

        // Create floating geometric shapes
        function createFloatingShapes() {
          const geometries = [
            new THREE.IcosahedronGeometry(1.8, 0),
            new THREE.OctahedronGeometry(1.5, 0),
            new THREE.TorusGeometry(1.2, 0.5, 8, 16),
            new THREE.SphereGeometry(1.2, 16, 16),
            new THREE.TetrahedronGeometry(1.5, 0),
            new THREE.DodecahedronGeometry(1.3, 0),
            new THREE.TorusKnotGeometry(0.8, 0.3, 50, 8)
          ];

          const colorArray = [colors.primary, colors.secondary, colors.accent1, colors.accent2];

          for (let i = 0; i < 15; i++) {
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];
            const material = new THREE.MeshBasicMaterial({
              color: colorArray[Math.floor(Math.random() * colorArray.length)],
              wireframe: true,
              transparent: true,
              opacity: 0.4 + Math.random() * 0.3
            });

            const mesh = new THREE.Mesh(geometry, material);

            // Random position
            mesh.position.x = (Math.random() - 0.5) * 60;
            mesh.position.y = (Math.random() - 0.5) * 35;
            mesh.position.z = (Math.random() - 0.5) * 25 - 5;

            // Random rotation
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;

            // Store animation properties
            mesh.userData = {
              rotationSpeed: {
                x: (Math.random() - 0.5) * 0.015,
                y: (Math.random() - 0.5) * 0.015,
                z: (Math.random() - 0.5) * 0.008
              },
              floatSpeed: 0.4 + Math.random() * 0.6,
              floatOffset: Math.random() * Math.PI * 2,
              originalY: mesh.position.y,
              originalScale: 1,
              targetScale: 1,
              originalColor: material.color.getHex(),
              isHovered: false,
              pulsePhase: Math.random() * Math.PI * 2
            };

            scene.add(mesh);
            floatingShapes.push(mesh);
          }
        }

        // Create particle cloud
        function createParticles() {
          const particleCount = 400;
          const positions = new Float32Array(particleCount * 3);
          const particleColors = new Float32Array(particleCount * 3);
          const sizes = new Float32Array(particleCount);

          const color1 = new THREE.Color(0x4F46E5);
          const color2 = new THREE.Color(0x06B6D4);

          for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 60;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 50 - 15;

            const mixRatio = Math.random();
            const mixedColor = color1.clone().lerp(color2, mixRatio);
            particleColors[i * 3] = mixedColor.r;
            particleColors[i * 3 + 1] = mixedColor.g;
            particleColors[i * 3 + 2] = mixedColor.b;

            sizes[i] = 0.1 + Math.random() * 0.2;
          }

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

          const material = new THREE.PointsMaterial({
            size: 0.18,
            vertexColors: true,
            transparent: true,
            opacity: 0.7,
            sizeAttenuation: true
          });

          const particleSystem = new THREE.Points(geometry, material);
          scene.add(particleSystem);

          return particleSystem;
        }

        // Create click explosion effect
        function createClickExplosion(x, y, z) {
          const particleCount = 30;
          const explosionGroup = new THREE.Group();
          explosionGroup.position.set(x, y, z);

          const colorArray = [0x4F46E5, 0x06B6D4, 0x10B981, 0x8B5CF6, 0xFFFFFF];

          for (let i = 0; i < particleCount; i++) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({
              color: colorArray[Math.floor(Math.random() * colorArray.length)],
              transparent: true,
              opacity: 1
            });

            const particle = new THREE.Mesh(geometry, material);

            // Random velocity
            particle.userData = {
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
              ),
              life: 1.0,
              decay: 0.02 + Math.random() * 0.02
            };

            explosionGroup.add(particle);
          }

          scene.add(explosionGroup);
          clickParticles.push(explosionGroup);

          // Remove after animation
          setTimeout(() => {
            scene.remove(explosionGroup);
            const index = clickParticles.indexOf(explosionGroup);
            if (index > -1) clickParticles.splice(index, 1);
          }, 2000);
        }

        // Mouse tracking for parallax
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        heroSection.addEventListener('mousemove', (event) => {
          const rect = heroSection.getBoundingClientRect();
          mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          // Update mouse for raycasting
          mouse.x = mouseX;
          mouse.y = mouseY;
        });

        // Click handler for explosion effect
        heroSection.addEventListener('click', (event) => {
          const rect = heroSection.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);

          // Check if clicked on a shape
          const intersects = raycaster.intersectObjects(floatingShapes);

          if (intersects.length > 0) {
            const clickedShape = intersects[0].object;
            const pos = clickedShape.position;

            // Create explosion at shape position
            createClickExplosion(pos.x, pos.y, pos.z);

            // Animate the clicked shape
            clickedShape.userData.targetScale = 1.5;
            setTimeout(() => {
              clickedShape.userData.targetScale = 1;
            }, 300);

            // Spin faster temporarily
            clickedShape.userData.clickBoost = 0.1;
          } else {
            // Create explosion at ray intersection with z=0 plane
            const point = new THREE.Vector3();
            raycaster.ray.at(30, point);
            createClickExplosion(point.x, point.y, point.z);
          }
        });

        // Initialize scene
        createFloatingShapes();
        const particleSystem = createParticles();

        // Animation loop
        let time = 0;
        function animate() {
          requestAnimationFrame(animate);
          time += 0.01;

          // Smooth mouse following
          targetX += (mouseX - targetX) * 0.05;
          targetY += (mouseY - targetY) * 0.05;

          // Camera parallax - more responsive
          camera.position.x = targetX * 5;
          camera.position.y = targetY * 3;
          camera.lookAt(scene.position);

          // Raycasting for hover detection
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(floatingShapes);

          // Reset previous hover
          if (hoveredShape && (!intersects.length || intersects[0].object !== hoveredShape)) {
            hoveredShape.userData.isHovered = false;
            hoveredShape.userData.targetScale = 1;
            hoveredShape.material.color.setHex(hoveredShape.userData.originalColor);
            hoveredShape = null;
            canvas.style.cursor = 'default';
          }

          // Apply new hover
          if (intersects.length > 0) {
            const shape = intersects[0].object;
            if (!shape.userData.isHovered) {
              shape.userData.isHovered = true;
              shape.userData.targetScale = 1.3;
              shape.material.color.setHex(colors.highlight);
              hoveredShape = shape;
              canvas.style.cursor = 'pointer';
            }
          }

          // Animate floating shapes
          floatingShapes.forEach((shape) => {
            const userData = shape.userData;

            // Rotation with click boost decay
            const boost = userData.clickBoost || 0;
            shape.rotation.x += userData.rotationSpeed.x + boost;
            shape.rotation.y += userData.rotationSpeed.y + boost;
            shape.rotation.z += userData.rotationSpeed.z;

            if (userData.clickBoost) {
              userData.clickBoost *= 0.95;
              if (userData.clickBoost < 0.001) userData.clickBoost = 0;
            }

            // Gentle floating motion with pulse
            const pulse = Math.sin(time * 2 + userData.pulsePhase) * 0.1;
            shape.position.y = userData.originalY + Math.sin(time * userData.floatSpeed + userData.floatOffset) * 2;

            // Smooth scale transition
            const currentScale = shape.scale.x;
            const targetScale = userData.targetScale + pulse;
            const newScale = currentScale + (targetScale - currentScale) * 0.1;
            shape.scale.set(newScale, newScale, newScale);

            // Hover glow effect
            if (userData.isHovered) {
              shape.material.opacity = 0.7 + Math.sin(time * 8) * 0.2;
            } else {
              shape.material.opacity = 0.4 + Math.sin(time * 2 + userData.pulsePhase) * 0.15;
            }
          });

          // Animate click particles
          clickParticles.forEach((group) => {
            group.children.forEach((particle) => {
              particle.position.add(particle.userData.velocity);
              particle.userData.velocity.multiplyScalar(0.96);
              particle.userData.life -= particle.userData.decay;
              particle.material.opacity = particle.userData.life;
              particle.scale.multiplyScalar(0.98);
            });
          });

          // Rotate particle system with wave
          if (particleSystem) {
            particleSystem.rotation.y += 0.0008;
            particleSystem.rotation.x = Math.sin(time * 0.5) * 0.1;
          }

          renderer.render(scene, camera);
        }

        // Handle window resize
        function handleResize() {
          const width = heroSection.offsetWidth;
          const height = heroSection.offsetHeight;

          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        window.addEventListener('resize', handleResize);

        // Start animation
        animate();
      })();
    </script>

    <!-- Three.js Features Section Animation -->
    <script>
      (function () {
        const canvas = document.getElementById('threejs-features-canvas');
        const featuresSection = document.querySelector('.features-section');
        if (!canvas || !featuresSection) return;

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, featuresSection.offsetWidth / featuresSection.offsetHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setSize(featuresSection.offsetWidth, featuresSection.offsetHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        camera.position.z = 25;

        // Medical/Healthcare themed colors
        const colors = {
          teal: 0x14B8A6,
          cyan: 0x06B6D4,
          indigo: 0x6366F1,
          emerald: 0x10B981,
          white: 0xFFFFFF
        };

        // Create floating crosses (medical symbol)
        const floatingElements = [];

        function createMedicalCross() {
          const group = new THREE.Group();
          const material = new THREE.MeshBasicMaterial({
            color: colors.teal,
            wireframe: true,
            transparent: true,
            opacity: 0.6
          });

          // Vertical bar
          const vGeom = new THREE.BoxGeometry(0.3, 1.2, 0.1);
          const vMesh = new THREE.Mesh(vGeom, material);
          group.add(vMesh);

          // Horizontal bar
          const hGeom = new THREE.BoxGeometry(1.2, 0.3, 0.1);
          const hMesh = new THREE.Mesh(hGeom, material);
          group.add(hMesh);

          return group;
        }

        // Create DNA helix points
        function createDNAHelix() {
          const points1 = [];
          const points2 = [];
          const connectors = [];

          for (let i = 0; i < 50; i++) {
            const t = i * 0.3;
            const x = Math.sin(t) * 2;
            const y = t - 7.5;
            const z = Math.cos(t) * 2;
            points1.push(new THREE.Vector3(x, y, z));
            points2.push(new THREE.Vector3(-x, y, -z));
          }

          const curve1 = new THREE.CatmullRomCurve3(points1);
          const curve2 = new THREE.CatmullRomCurve3(points2);

          const helixMat = new THREE.LineBasicMaterial({
            color: colors.cyan,
            transparent: true,
            opacity: 0.4
          });

          const helix1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(curve1.getPoints(100)), helixMat);
          const helix2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(curve2.getPoints(100)), helixMat.clone());
          helix2.material.color.setHex(colors.emerald);

          const helixGroup = new THREE.Group();
          helixGroup.add(helix1);
          helixGroup.add(helix2);

          // Add connectors
          const connectorMat = new THREE.LineBasicMaterial({
            color: colors.white,
            transparent: true,
            opacity: 0.2
          });

          for (let i = 0; i < 50; i += 3) {
            const p1 = points1[i];
            const p2 = points2[i];
            const lineGeom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            const line = new THREE.Line(lineGeom, connectorMat);
            helixGroup.add(line);
          }

          return helixGroup;
        }

        // Create multiple DNA helixes
        const dnaHelixes = [];
        for (let i = 0; i < 3; i++) {
          const helix = createDNAHelix();
          helix.position.set(
            (Math.random() - 0.5) * 40,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 20 - 10
          );
          helix.rotation.z = Math.random() * Math.PI;
          helix.scale.setScalar(0.8 + Math.random() * 0.4);
          helix.userData = {
            rotationSpeed: 0.002 + Math.random() * 0.003,
            floatSpeed: 0.5 + Math.random() * 0.5,
            floatOffset: Math.random() * Math.PI * 2,
            originalY: helix.position.y
          };
          scene.add(helix);
          dnaHelixes.push(helix);
        }

        // Create floating medical crosses
        for (let i = 0; i < 8; i++) {
          const cross = createMedicalCross();
          cross.position.set(
            (Math.random() - 0.5) * 35,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 15 - 5
          );
          cross.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
          const colorArr = [colors.teal, colors.cyan, colors.emerald, colors.indigo];
          cross.children.forEach(child => {
            child.material = child.material.clone();
            child.material.color.setHex(colorArr[Math.floor(Math.random() * colorArr.length)]);
          });
          cross.userData = {
            rotationSpeed: {
              x: (Math.random() - 0.5) * 0.01,
              y: (Math.random() - 0.5) * 0.01,
              z: (Math.random() - 0.5) * 0.01
            },
            floatSpeed: 0.3 + Math.random() * 0.5,
            floatOffset: Math.random() * Math.PI * 2,
            originalY: cross.position.y
          };
          scene.add(cross);
          floatingElements.push(cross);
        }

        // Create subtle particle system
        const particleCount = 150;
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 50;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 30;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 30 - 10;

          // Gradient colors
          const color = new THREE.Color().lerpColors(
            new THREE.Color(colors.teal),
            new THREE.Color(colors.cyan),
            Math.random()
          );
          particleColors[i * 3] = color.r;
          particleColors[i * 3 + 1] = color.g;
          particleColors[i * 3 + 2] = color.b;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.08,
          vertexColors: true,
          transparent: true,
          opacity: 0.5
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        // Animation
        let time = 0;
        function animate() {
          requestAnimationFrame(animate);
          time += 0.01;

          // Animate DNA helixes
          dnaHelixes.forEach((helix) => {
            helix.rotation.y += helix.userData.rotationSpeed;
            helix.position.y = helix.userData.originalY + Math.sin(time * helix.userData.floatSpeed + helix.userData.floatOffset) * 1;
          });

          // Animate medical crosses
          floatingElements.forEach((element) => {
            element.rotation.x += element.userData.rotationSpeed.x;
            element.rotation.y += element.userData.rotationSpeed.y;
            element.rotation.z += element.userData.rotationSpeed.z;
            element.position.y = element.userData.originalY + Math.sin(time * element.userData.floatSpeed + element.userData.floatOffset) * 1.5;
          });

          // Gentle particle movement
          particleSystem.rotation.y += 0.0003;
          particleSystem.rotation.x = Math.sin(time * 0.3) * 0.05;

          renderer.render(scene, camera);
        }

        // Handle resize
        function handleResize() {
          const width = featuresSection.offsetWidth;
          const height = featuresSection.offsetHeight;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }

        window.addEventListener('resize', handleResize);

        // Start animation
        animate();
      })();
    </script>

    <!-- Feature Carousel Navigation Controls -->
    <script>
      (function () {
        const featuresGrid = document.querySelector('.features-grid');
        const featuresWrapper = document.querySelector('.features-marquee-wrapper');
        const prevBtn = document.getElementById('feature-prev');
        const nextBtn = document.getElementById('feature-next');
        const uniqueCards = 5; // Only count original cards, not duplicates

        if (!featuresGrid || !prevBtn || !nextBtn || !featuresWrapper) return;

        let currentIndex = 0;
        let isStepMode = false;
        let resumeTimeout = null;
        const cardWidth = 280; // Card min-width
        const gap = 32; // 2rem gap

        // Calculate how many cards are visible at once
        function getVisibleCards() {
          return Math.floor(featuresWrapper.offsetWidth / (cardWidth + gap)) || 1;
        }

        // Get current transform X position from animation
        function getCurrentTransformX() {
          const style = window.getComputedStyle(featuresGrid);
          const matrix = style.transform;
          if (matrix === 'none') return 0;

          // Parse matrix(a, b, c, d, tx, ty) or matrix3d(...)
          const matrixValues = matrix.match(/matrix.*\((.+)\)/);
          if (!matrixValues) return 0;

          const values = matrixValues[1].split(', ');
          // For matrix(), tx is the 5th value (index 4)
          // For matrix3d(), tx is the 13th value (index 12)
          const tx = values.length === 6 ? parseFloat(values[4]) : parseFloat(values[12]);
          return tx || 0;
        }

        // Enter step mode (pause marquee, enable navigation)
        function enterStepMode() {
          if (isStepMode) return;
          isStepMode = true;
          clearTimeout(resumeTimeout);

          // Get current exact position from animation
          const currentX = getCurrentTransformX();
          const cardStep = cardWidth + gap;

          // Calculate which card is closest (for navigation tracking)
          currentIndex = Math.round(Math.abs(currentX) / cardStep);
          currentIndex = Math.max(0, Math.min(currentIndex, uniqueCards - 1));

          // Add step-mode class to disable animation and enable transitions
          featuresGrid.classList.add('step-mode');

          // Keep exact position (freeze in place)
          featuresGrid.style.transform = `translateX(${currentX}px)`;

          updateButtonStates();
        }

        // Exit step mode (resume marquee)
        function exitStepMode() {
          if (!isStepMode) return;

          // Delay before resuming to allow user to click buttons
          resumeTimeout = setTimeout(() => {
            isStepMode = false;
            currentIndex = 0;
            featuresGrid.classList.remove('step-mode');
            featuresGrid.style.transform = '';
          }, 500);
        }

        // Update button opacity based on position (always active for infinite carousel)
        function updateButtonStates() {
          // Both buttons always active in infinite mode
          prevBtn.style.opacity = '1';
          prevBtn.style.cursor = 'pointer';
          nextBtn.style.opacity = '1';
          nextBtn.style.cursor = 'pointer';
        }

        // Navigate to position (with wrap-around for infinite carousel)
        function goToIndex(index) {
          const maxIndex = uniqueCards - 1;

          // Wrap around for infinite carousel
          if (index < 0) {
            currentIndex = maxIndex;
          } else if (index > maxIndex) {
            currentIndex = 0;
          } else {
            currentIndex = index;
          }

          featuresGrid.style.transform = `translateX(-${currentIndex * (cardWidth + gap)}px)`;
          updateButtonStates();
        }

        // Button hover - enter step mode
        prevBtn.addEventListener('mouseenter', enterStepMode);
        nextBtn.addEventListener('mouseenter', enterStepMode);

        // Button leave - try to exit step mode
        prevBtn.addEventListener('mouseleave', exitStepMode);
        nextBtn.addEventListener('mouseleave', exitStepMode);

        // Navigate on click (infinite - always works)
        prevBtn.addEventListener('click', () => {
          goToIndex(currentIndex - 1);
        });

        nextBtn.addEventListener('click', () => {
          goToIndex(currentIndex + 1);
        });

        // Update on resize
        window.addEventListener('resize', () => {
          if (isStepMode) {
            goToIndex(currentIndex);
          }
        });
      })();
    </script>
    <!-- Scroll Reveal Animation (Repeatable) -->
    <script>
      (function () {
        // Get all feature cards
        const featureCards = document.querySelectorAll('.feature-card');
        const featuresSection = document.querySelector('.features-section');

        // Get dashboard elements
        const dashboardSection = document.querySelector('.dashboard');
        const dashboardTable = document.querySelector('.dashboard table');

        // Create Intersection Observer for features (repeatable)
        const featuresObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              // Add revealed class when scrolling into view
              featureCards.forEach((card) => {
                card.classList.add('scroll-revealed');
              });
            } else {
              // Remove class when scrolling out of view (top) so it animates again
              featureCards.forEach((card) => {
                card.classList.remove('scroll-revealed');
              });
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px 0px -50px 0px'
        });

        // Create Intersection Observer for dashboard (repeatable)
        const dashboardObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              // Add revealed class when scrolling into view
              if (dashboardTable) {
                dashboardTable.classList.add('scroll-revealed');
              }
              const title = entry.target.querySelector('.section-title');
              if (title) {
                title.classList.add('scroll-revealed');
              }
            } else {
              // Remove class when scrolling out of view so it animates again
              if (dashboardTable) {
                dashboardTable.classList.remove('scroll-revealed');
              }
              const title = entry.target.querySelector('.section-title');
              if (title) {
                title.classList.remove('scroll-revealed');
              }
            }
          });
        }, {
          threshold: 0.1,
          rootMargin: '0px 0px -80px 0px'
        });

        // Observe sections (continuously)
        if (featuresSection && featureCards.length) {
          featuresObserver.observe(featuresSection);
        }
        if (dashboardSection) {
          dashboardObserver.observe(dashboardSection);
        }
      })();

      // Navbar scroll visibility
      (function () {
        const nav = document.querySelector('nav');
        const heroSection = document.querySelector('.hero');

        function handleScroll() {
          // Show navbar after scrolling past 100px
          if (window.scrollY > 100) {
            nav.classList.add('nav-visible');
          } else {
            nav.classList.remove('nav-visible');
          }
        }

        // Initial check
        handleScroll();

        // Listen for scroll
        window.addEventListener('scroll', handleScroll, { passive: true });
      })();
    </script>

</body>

</html>